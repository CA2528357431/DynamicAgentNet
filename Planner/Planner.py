from pydantic import BaseModel, Field
from typing import List, Literal

from langchain.schema import HumanMessage, AIMessage, SystemMessage
from langchain.prompts import PromptTemplate, ChatPromptTemplate
from langchain_openai import ChatOpenAI


class Planner:
    def __init__(self, llm: ChatOpenAI, tools_description: dict):
        class SubTask(BaseModel):
            subtask: str = Field(description="The content of a sub-task.")
            tool_list: List[Literal[*[tool for tool in tools_description]]] = Field(
                description="The tools that are necessary to finish this sub-task.")
        class SubTaskList(BaseModel):
            subtask_list: List[SubTask] = Field(
                description="A list of sub-tasks that are generated by breaking down a complex task, and the tools needed for addressing each sub-task.")


        self.llm = llm.with_structured_output(SubTaskList)

        sys_prompt_text = '''
You are an intelligent Task Decomposition Planner. 
Your goal is to break down complex tasks into smaller, manageable, and logically ordered sub-tasks, **according to the descriptions of available tools**. 

Eventually, you need to output a list of sub-tasks, and the tools that are needed for each sub-task in the order of calling.
If one sub-task cannot be executed by available tools, set its tools to an empty list.
Each sub-task could use one or multiple tools.

Sub-tasks should be 
- Effective: Each sub-task should be aligned with the overall objective.
- Achievable: Each sub-task could be finished by tools you return.
- Specific: Each sub-task should have a clear goal.
- Independent: Sub-tasks should be modular and executable on their own.
- Sequential: Sub-tasks should follow a logical order.
- Concise: Only include necessary tools for each sub-task.
'''
        self.sys_prompt = SystemMessage(content=sys_prompt_text)

        tool_descriptions = [f"**{tool}**:\n{description}" for tool, description in tools_description.items()]

        tool_prompt_text = f'''
Here are available tools and their descriptions:

{"\n".join(tool_descriptions)} 
'''
        self.tool_prompt = SystemMessage(content=tool_prompt_text)

    def decompose_task(self, task):
        task_prompt_text = f'''
Here is the task to be broken down:        

{task}
'''
        task_prompt = HumanMessage(content=task_prompt_text)

        msgs = [self.sys_prompt, self.tool_prompt, task_prompt]

        prompt = ChatPromptTemplate.from_messages(messages=msgs)

        pipe = prompt | self.llm

        response = pipe.invoke({})

        return response.subtask_list

    def __call__(self, task):
        subtasks = self.decompose_task(task)
        return subtasks

